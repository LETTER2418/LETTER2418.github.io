<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>评价模型</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h1><h2 id="层次分析法（AHP）"><a href="#层次分析法（AHP）" class="headerlink" title="层次分析法（AHP）"></a>层次分析法（AHP）</h2><ul><li><p>一种将与决策有关的元素分解成目标、准则、方案等多个层次，并在此基础上进行定性和定量分析的决策方法。</p></li><li><p>基本步骤</p><ul><li><strong>建立层次结构模型</strong>：将决策问题分解为目标、准则（或标准）和方案（或备选方案）等层次。</li><li><strong>构造判断矩阵</strong>：通过两两比较，确定各层次因素之间的相对重要性。</li><li><strong>计算权重</strong>：通过数学方法（算数平均法、几何平均法和特征值法）计算各因素的权重。</li><li><strong>一致性检验</strong>：检查判断矩阵的一致性，确保决策者的判断逻辑合理。</li><li><strong>综合决策</strong>：根据权重和层次结构，计算各备选方案的总得分，从而做出决策。</li></ul></li></ul><ul><li><p>```python<br>import numpy as np</p><p>def calculate_weights(matrix):</p><pre><code>&quot;&quot;&quot;计算判断矩阵的权重。&quot;&quot;&quot;# 计算几何平均geometric_mean = np.prod(matrix, axis=1) ** (1 / matrix.shape[0])# 归一化得到权重weights = geometric_mean / np.sum(geometric_mean)return weights</code></pre><p>def check_consistency(matrix, weights):</p><pre><code>&quot;&quot;&quot;检查判断矩阵的一致性。&quot;&quot;&quot;n = matrix.shape[0]# 计算加权和weighted_sum = np.dot(matrix, weights)# 计算 lambda_maxlambda_max = np.mean(weighted_sum / weights)# 计算一致性指标 (CI)CI = (lambda_max - n) / (n - 1)# 随机一致性指标 (RI)，根据 n 的值查表RI = &#123;1: 0, 2: 0, 3: 0.58, 4: 0.90, 5: 1.12, 6: 1.24, 7: 1.32, 8: 1.41, 9: 1.45, 10: 1.49&#125;# 计算一致性比率 (CR)CR = CI / RI[n]return CR</code></pre><h1 id="定义准则判断矩阵"><a href="#定义准则判断矩阵" class="headerlink" title="定义准则判断矩阵"></a>定义准则判断矩阵</h1><p>criteria_matrix = np.array([</p><pre><code>[1, 3, 5],  # 价格 vs 质量 vs 交货时间[1/3, 1, 2],  # 质量 vs 价格 vs 交货时间[1/5, 1/2, 1]  # 交货时间 vs 价格 vs 质量</code></pre><p>])</p><h1 id="计算准则权重"><a href="#计算准则权重" class="headerlink" title="计算准则权重"></a>计算准则权重</h1><p>criteria_weights = calculate_weights(criteria_matrix)<br>print(“准则权重:”, criteria_weights)</p><h1 id="检查准则判断矩阵的一致性"><a href="#检查准则判断矩阵的一致性" class="headerlink" title="检查准则判断矩阵的一致性"></a>检查准则判断矩阵的一致性</h1><p>CR = check_consistency(criteria_matrix, criteria_weights)<br>print(“准则一致性比率 (CR):”, CR)<br>if CR &lt; 0.1:</p><pre><code>print(&quot;准则判断矩阵一致性可接受。&quot;)</code></pre><p>else:</p><pre><code>print(&quot;准则判断矩阵一致性不可接受，需要调整。&quot;)</code></pre><h1 id="定义各准则下的供应商判断矩阵"><a href="#定义各准则下的供应商判断矩阵" class="headerlink" title="定义各准则下的供应商判断矩阵"></a>定义各准则下的供应商判断矩阵</h1><p>price_matrix = np.array([</p><pre><code>[1, 2, 4],  # A vs B vs C[1/2, 1, 3],  # B vs A vs C[1/4, 1/3, 1]  # C vs A vs B</code></pre><p>])</p><p>quality_matrix = np.array([</p><pre><code>[1, 1/3, 1/5],  # A vs B vs C[3, 1, 1/2],  # B vs A vs C[5, 2, 1]  # C vs A vs B</code></pre><p>])</p><p>delivery_matrix = np.array([</p><pre><code>[1, 5, 3],  # A vs B vs C[1/5, 1, 1/2],  # B vs A vs C[1/3, 2, 1]  # C vs A vs B</code></pre><p>])</p><h1 id="计算各准则下的供应商权重"><a href="#计算各准则下的供应商权重" class="headerlink" title="计算各准则下的供应商权重"></a>计算各准则下的供应商权重</h1><p>price_weights = calculate_weights(price_matrix)<br>quality_weights = calculate_weights(quality_matrix)<br>delivery_weights = calculate_weights(delivery_matrix)</p><p>print(“价格权重:”, price_weights)<br>print(“质量权重:”, quality_weights)<br>print(“交货时间权重:”, delivery_weights)</p><h1 id="检查各准则判断矩阵的一致性"><a href="#检查各准则判断矩阵的一致性" class="headerlink" title="检查各准则判断矩阵的一致性"></a>检查各准则判断矩阵的一致性</h1><p>CR_price = check_consistency(price_matrix, price_weights)<br>CR_quality = check_consistency(quality_matrix, quality_weights)<br>CR_delivery = check_consistency(delivery_matrix, delivery_weights)</p><p>print(“价格判断矩阵一致性比率 (CR):”, CR_price)<br>print(“质量判断矩阵一致性比率 (CR):”, CR_quality)<br>print(“交货时间判断矩阵一致性比率 (CR):”, CR_delivery)</p><h1 id="综合得分"><a href="#综合得分" class="headerlink" title="综合得分"></a>综合得分</h1><p>supplier_scores = np.array([</p><pre><code>np.sum(price_weights * criteria_weights[0]),np.sum(quality_weights * criteria_weights[1]),np.sum(delivery_weights * criteria_weights[2])</code></pre><p>])</p><h1 id="输出最终得分"><a href="#输出最终得分" class="headerlink" title="输出最终得分"></a>输出最终得分</h1><p>supplier_names = [‘A’, ‘B’, ‘C’]<br>for name, score in zip(supplier_names, supplier_scores):</p><pre><code>print(f&quot;供应商 &#123;name&#125; 的综合得分: &#123;score:.4f&#125;&quot;)</code></pre><h1 id="选择最佳供应商"><a href="#选择最佳供应商" class="headerlink" title="选择最佳供应商"></a>选择最佳供应商</h1><p>best_supplier = supplier_names[np.argmax(supplier_scores)]<br>print(f”最佳供应商是: {best_supplier}”)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 主成分分析评价法(PCA)</span><br><span class="line"></span><br><span class="line">- 将多个变量通过线性变换以选出较少个数重要变量的一种多元统计分析方法。</span><br><span class="line"></span><br><span class="line">- 主成分保留了原始变量绝大多数信息。各个主成分之间互不相关。每个主成分都是原始变量的线性组合。</span><br><span class="line"></span><br><span class="line">- 基本步骤</span><br><span class="line">  - 无量纲化</span><br><span class="line">    - 归一化：min-max归一化，平均归一化 </span><br><span class="line">    - 标准化：均值为0，协方差为1</span><br><span class="line">  - 计算协方差矩阵</span><br><span class="line">  - 计算协方差矩阵的特征值和特征向量</span><br><span class="line">  - 选择主成分：根据特征值的大小，选择前 k 个最大的特征值对应的特征向量，作为主成分</span><br><span class="line">  - 构建投影矩阵：将选择的 k 个特征向量组成投影矩阵 </span><br><span class="line">  - 数据降维：将原始数据 X 投影到主成分空间，得到降维后的数据 </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  from sklearn.decomposition import PCA</span><br><span class="line">  from sklearn.preprocessing import StandardScaler</span><br><span class="line">  import numpy as np</span><br><span class="line">  </span><br><span class="line">  # 示例数据</span><br><span class="line">  X = np.array([[1, 2], [3, 4], [5, 6]])</span><br><span class="line">  </span><br><span class="line">  # 数据标准化</span><br><span class="line">  scaler = StandardScaler()</span><br><span class="line">  X_standardized = scaler.fit_transform(X)</span><br><span class="line">  </span><br><span class="line">  # 执行 PCA</span><br><span class="line">  pca = PCA(n_components=2)  # 选择降维后的维度</span><br><span class="line">  X_pca = pca.fit_transform(X_standardized)</span><br><span class="line">  # X_standardized 是原始数据，形状为 (n_samples, n_features)。</span><br><span class="line">  # X_pca 是降维后的数据，形状为 (n_samples, n_components)。</span><br><span class="line">  </span><br><span class="line">  # 输出结果</span><br><span class="line">  print(&quot;降维后的数据：\n&quot;, X_pca)</span><br><span class="line">  print(&quot;解释方差比例：&quot;, pca.explained_variance_ratio_)</span><br></pre></td></tr></table></figure></li></ul><h2 id="模糊综合评价法"><a href="#模糊综合评价法" class="headerlink" title="模糊综合评价法"></a>模糊综合评价法</h2><ul><li><p>一种基于模糊数学的综合评价方法，用于处理具有模糊性和不确定性的问题。它通过将定性指标转化为定量评价，适用于多因素、多层次的复杂系统评价。</p></li><li><p>基本步骤</p><ul><li><strong>确定评价因素集</strong><br>明确影响评价对象的各个因素，记为 U。</li><li><strong>确定评语集</strong><br>设定评价等级，记为 V。</li><li><strong>确定权重集</strong><br>为各因素分配权重，反映其重要性，记为W，且权重和为1。</li><li><strong>构建模糊关系矩阵</strong><br>通过专家打分或数据分析，确定每个因素对评语集的隶属度，形成模糊关系矩阵 R。</li><li><strong>进行模糊合成运算</strong><br>将权重集 W与模糊关系矩阵 R合成，得到模糊评价结果 B=W∘R。</li><li><strong>得出综合评价结果</strong><br>对 B 进行去模糊化处理，得到最终评价结果。</li></ul></li><li><pre><code class="lang-python">import numpy as npdef fuzzy_comprehensive_evaluation(weights, fuzzy_relation_matrix, scores):    &quot;&quot;&quot;    模糊综合评价法    :param weights: 权重集，格式为 numpy 数组，例如 np.array([0.3, 0.5, 0.2])    :param fuzzy_relation_matrix: 模糊关系矩阵，格式为 numpy 二维数组    :param scores: 每个评语对应的分数，格式为 numpy 数组，例如 np.array([5, 4, 3, 2, 1])    :return: 模糊评价结果（隶属度）和系统总得分    &quot;&quot;&quot;    # 检查权重和模糊关系矩阵的维度是否匹配    # 在 NumPy 中，一维数组的形状表示为 (n,)，其中 n 是数组的长度    if weights.shape[0] != fuzzy_relation_matrix.shape[0]:        raise ValueError(&quot;权重集和模糊关系矩阵的维度不匹配！&quot;)    # 模糊合成运算（使用加权平均法）    evaluation_result = np.dot(weights, fuzzy_relation_matrix)    # 归一化处理（确保评价结果的总和为1）    evaluation_result = evaluation_result / np.sum(evaluation_result)    # 计算系统总得分    total_score = np.dot(evaluation_result, scores)    return evaluation_result, total_score# 示例数据if __name__ == &quot;__main__&quot;:    # 权重集：外观、性能、价格的权重分别为 0.3, 0.5, 0.2    weights = np.array([0.3, 0.5, 0.2])    # 模糊关系矩阵：每一行对应一个因素，每一列对应一个评语    # 例如，外观的模糊关系为 [0.6, 0.3, 0.1, 0.0, 0.0]    fuzzy_relation_matrix = np.array([        [0.6, 0.3, 0.1, 0.0, 0.0],  # 外观        [0.4, 0.4, 0.2, 0.0, 0.0],  # 性能        [0.1, 0.2, 0.5, 0.2, 0.0]   # 价格    ])    # 每个评语对应的分数：好=5分，较好=4分，一般=3分，较差=2分，差=1分    scores = np.array([5, 4, 3, 2, 1])    # 进行模糊综合评价    result, total_score = fuzzy_comprehensive_evaluation(weights, fuzzy_relation_matrix, scores)    # 输出结果    print(&quot;模糊综合评价结果（隶属度）：&quot;, result)    print(&quot;系统总得分：&quot;, total_score)</code></pre></li></ul><h2 id="灰色综合评价法"><a href="#灰色综合评价法" class="headerlink" title="灰色综合评价法"></a>灰色综合评价法</h2><h2 id="熵权法"><a href="#熵权法" class="headerlink" title="熵权法"></a>熵权法</h2><h2 id="人工神经网络评价法"><a href="#人工神经网络评价法" class="headerlink" title="人工神经网络评价法"></a>人工神经网络评价法</h2><h2 id="数据包络分析法（DEA"><a href="#数据包络分析法（DEA" class="headerlink" title="数据包络分析法（DEA)"></a>数据包络分析法（DEA)</h2>]]></content>
      
      
      <categories>
          
          <category> 数模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评价 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化模型-规划模型</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="优化模型-规划模型"><a href="#优化模型-规划模型" class="headerlink" title="优化模型-规划模型"></a>优化模型-规划模型</h1><h2 id="数学规划"><a href="#数学规划" class="headerlink" title="数学规划"></a>数学规划</h2><p>数学规划（Mathematical Programming）是运筹学的一个分支，研究在给定的条件（约束条件）下，如何按照某一衡量指标（目标函数）来寻求计划、管理、工作中的最优方案。通俗来讲就是：求目标函数在一定约束条件下的极值问题。</p><h2 id="线性规划-LP"><a href="#线性规划-LP" class="headerlink" title="线性规划(LP)"></a>线性规划(LP)</h2><ul><li><p>定义：目标函数和约束条件均是决策变量的线性表达式。</p></li><li><p>线性规划有通用求准确解的方法，它的最优解只存在于可行域的边界上。</p></li><li><p>中小规模问题：使用单纯形法。</p></li><li><p>大规模问题：使用内点法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize <span class="keyword">as</span> op</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出变量取值范围</span></span><br><span class="line">x1 = (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">x2 = (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">x3 = (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">c = np.array([-<span class="number">2</span>, -<span class="number">3</span>, <span class="number">5</span>])  <span class="comment"># 目标函数系数,3x1列向量</span></span><br><span class="line"></span><br><span class="line">A_ub = np.array([[-<span class="number">2</span>, <span class="number">5</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]])  <span class="comment"># 不等式约束系数A，2x3维矩阵</span></span><br><span class="line">B_ub = np.array([-<span class="number">10</span>, <span class="number">12</span>])  <span class="comment"># 等式约束系数b, 2x1维列向量</span></span><br><span class="line">A_eq = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># 等式约束系数Aeq，3x1维列向量</span></span><br><span class="line">B_eq = np.array([<span class="number">7</span>])  <span class="comment"># 等式约束系数beq，1x1数值</span></span><br><span class="line"></span><br><span class="line">res = op.linprog(c, A_ub, B_ub, A_eq, B_eq, bounds=(x1, x2, x3), method=<span class="string">&#x27;highs&#x27;</span>)  <span class="comment"># 调用函数进行求解</span></span><br><span class="line"><span class="comment">#奇怪的警告,scipy还是牢版本,不管了</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="非线性规划-NLP"><a href="#非线性规划-NLP" class="headerlink" title="非线性规划(NLP)"></a>非线性规划(NLP)</h2><ul><li><p>定义：目标函数或约束条件中存在非线性表达式。 </p></li><li><p>非线性规划的最优解（若存在）可能在其可行域的任一点达到，目前非线性规划还没有适合各种问题的一般解法，各种方法都有其特定的适用范围。</p></li><li><p>Scipy 工具包中的 optimize 模块可求解常见的非线性规划问题。</p><ul><li>brent()：SciPy.optimize 模块中求解<strong>单变量无约束优化</strong>问题的首选方法，<strong>局部优化方法</strong>，混合使用牛顿法/二分法。既能保证稳定性又能快速收敛。 </li><li>fmin()：SciPy.optimize 模块中求解<strong>多变量无约束优化</strong>问题的首选方法，<strong>局部优化方法</strong>，不要求目标函数是凸函数。采用下山单纯形方法。下山单纯形方法又称 Nelder-Mead 法，只使用目标函数值，不需要导数或二阶导数值,适合目标函数不可导或梯度难以计算的情况。但是，因为它不使用任何梯度评估，所以可能需要更长的时间才能找到最小值。</li><li>leatsq()：求解非线性最小二乘拟合问题，<strong>局部优化方法</strong>。</li><li>minimize()： SciPy.optimize 模块中求解多变量优化问题的通用方法，可以调用多种算法，支持约束优化和无约束优化，支持等式和不等式约束。</li><li>differential_evolution():<strong>全局优化</strong>方法，无导数优化方法，适用于目标函数不可导或导数难以计算的情况，鲁棒性强，直接支持约束优化。</li><li>basinhopping():<strong>全局优化</strong>方法，无导数优化方法，适用于目标函数不可导或导数难以计算的情况，鲁棒性强，不直接支持约束优化。</li></ul></li></ul><h3 id="scipy-optimize-minimize"><a href="#scipy-optimize-minimize" class="headerlink" title="scipy.optimize.minimize"></a>scipy.optimize.minimize</h3><ul><li><p>求解函数为<strong>凸函数</strong>时，所求结果为<strong>最小值</strong>。求解函数为<strong>非凸函数</strong>时，只能求解<strong>局部最优解</strong>。</p></li><li><p>约束条件中默认为大于等于约束  。</p></li><li><p>在非线性优化问题通常对初始猜测值敏感，不同的初始猜测可能导致不同的结果。</p></li><li><p>初始猜测应满足所有约束条件，否则可能导致优化失败。</p></li><li><p>constraints: 一个字典（单个约束）或一个包含多个字典的列表/元组（多个约束）</p></li><li><p>Bounds:变量上下界的元组的列表/元组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">c1=np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]); c2=np.array([-<span class="number">8</span>,-<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>])</span><br><span class="line">A=np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>],</span><br><span class="line">            [<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>]])</span><br><span class="line">b=np.array([<span class="number">400</span>,<span class="number">800</span>,<span class="number">200</span>,<span class="number">200</span>])</span><br><span class="line">obj=<span class="keyword">lambda</span> x: -c1@x**<span class="number">2</span>+(-c2)@x</span><br><span class="line">cons=&#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>,<span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x:b-A@x&#125;</span><br><span class="line">bd=[(<span class="number">0</span>,<span class="number">99</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A.shape[<span class="number">1</span>])]</span><br><span class="line">res=minimize(obj,np.ones(<span class="number">5</span>),constraints=cons,bounds=bd)</span><br><span class="line">res</span><br></pre></td></tr></table></figure></li></ul><h3 id="scipy-optimize-differential-evolution-amp-basinhopping"><a href="#scipy-optimize-differential-evolution-amp-basinhopping" class="headerlink" title="scipy.optimize.differential_evolution &amp; basinhopping"></a>scipy.optimize.differential_evolution &amp; basinhopping</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> differential_evolution, basinhopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun_nonconvex</span>(<span class="params">x</span>): </span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ( x + <span class="number">2</span> ) ** <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> ( x - <span class="number">2</span> ) ** <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res_differential_evolution = differential_evolution(func=fun_nonconvex, bounds=[(-<span class="number">10</span>,<span class="number">10</span>)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;differential_evolution()的结果为：\n&#x27;</span>, res_differential_evolution)</span><br><span class="line"></span><br><span class="line">res_basinhopping = basinhopping(func=fun_nonconvex, x0=<span class="number">0</span>, niter=<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n basinhopping()的结果为：\n&#x27;</span>, res_basinhopping)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><h3 id="线性整数规划"><a href="#线性整数规划" class="headerlink" title="线性整数规划"></a>线性整数规划</h3><p>scipy库不能求解如背包问题的0-1规划问题，或整数规划问题，混合整数规划问题。Pulp库是一个用于线性规划（LP）、整数线性规划（ILP）和混合整数线性规划（MILP）问题的Python库，支持调用商业求解器处理大规模问题(留坑)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pulp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个线性规划问题，最大化总回报</span></span><br><span class="line">model = pulp.LpProblem(<span class="string">&quot;Maximize_Return&quot;</span>, pulp.LpMaximize)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义决策变量</span></span><br><span class="line">x_1 = pulp.LpVariable(<span class="string">&#x27;x_1&#x27;</span>, lowBound=<span class="number">0</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)   </span><br><span class="line">x_2 = pulp.LpVariable(<span class="string">&#x27;x_2&#x27;</span>, lowBound=<span class="number">0</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)   </span><br><span class="line">x_3 = pulp.LpVariable(<span class="string">&#x27;x_3&#x27;</span>, lowBound=<span class="number">0</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)   </span><br><span class="line">x_4 = pulp.LpVariable(<span class="string">&#x27;x_4&#x27;</span>, lowBound=<span class="number">0</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)   </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 建立目标函数</span></span><br><span class="line">model += <span class="number">800</span> * x_1 + <span class="number">600</span> * x_2 + <span class="number">700</span> * x_3 + <span class="number">500</span> * x_4, <span class="string">&quot;Total Return&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 建立约束条件</span></span><br><span class="line">model += <span class="number">500</span> * x_1 + <span class="number">300</span> * x_2 + <span class="number">400</span> * x_3 + <span class="number">200</span> * x_4 &lt;= <span class="number">1000</span>, <span class="string">&quot;Budget Constraint&quot;</span></span><br><span class="line">model += x_3 == <span class="number">0</span>, <span class="string">&quot;Risk Constraint for Project 3&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 解决问题</span></span><br><span class="line">model.solve()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看解的状态</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Status:&quot;</span>, LpStatus[prob.status])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出每个变量的最优值</span></span><br><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> model.variables():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;variable.name&#125;</span> = <span class="subst">&#123;variable.varValue&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出最优解的目标函数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;F3(x) =&quot;</span>, pulp.value(model.objective))</span><br></pre></td></tr></table></figure><h3 id="非线性整数规划"><a href="#非线性整数规划" class="headerlink" title="非线性整数规划"></a>非线性整数规划</h3><h4 id="Gekko"><a href="#Gekko" class="headerlink" title="Gekko"></a>Gekko</h4><ul><li><p>Gekko是一个Python库，用于解决优化问题，包括线性和非线性规划、整数规划、动态优化等。Gekko提供了易于使用的接口，并支持多种求解器，包括APOPT、BPOPT和IPOPT等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gekko <span class="keyword">import</span> GEKKO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Gekko模型</span></span><br><span class="line">m = GEKKO(remote=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个整数变量x和y，并设置它们的上下界</span></span><br><span class="line">x = m.Var(integer=<span class="literal">True</span>, lb=<span class="number">0</span>, ub=<span class="number">4</span>)</span><br><span class="line">y = m.Var(integer=<span class="literal">True</span>, lb=<span class="number">0</span>, ub=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标函数</span></span><br><span class="line">m.Obj(x**<span class="number">2</span> + y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义约束条件</span></span><br><span class="line">m.Equation(x + y &lt;= <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解问题</span></span><br><span class="line">m.options.SOLVER = <span class="number">1</span>  <span class="comment"># 使用 APOPT 求解器（适合混合整数非线性问题）</span></span><br><span class="line">m.solve(disp=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Results&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x: &#x27;</span> + <span class="built_in">str</span>(x.value[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y: &#x27;</span> + <span class="built_in">str</span>(y.value[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Objective: &#x27;</span> + <span class="built_in">str</span>(m.options.objfcnval))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="CVXPY"><a href="#CVXPY" class="headerlink" title="CVXPY"></a>CVXPY</h4><ul><li><p>用于解决凸优化问题（整数规划、01规划和混合规划）的Python库。对于凸函数的非线性规划，cvxpy包相对scipy,pulp更专业，功能也更强大。</p></li><li><p>部分博客说不能pip install，从实践来看有误。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">m = <span class="number">15</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">s0 = np.random.randn(m)</span><br><span class="line">lamb0 = np.maximum(-s0, <span class="number">0</span>)</span><br><span class="line">s0 = np.maximum(s0, <span class="number">0</span>)</span><br><span class="line">x0 = np.random.randn(n)</span><br><span class="line">A = np.random.randn(m, n)</span><br><span class="line">b = A @ x0 + s0</span><br><span class="line">c = -A.T @ lamb0</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Define and solve the CVXPY problem.</span></span><br><span class="line">x = cp.Variable(n)</span><br><span class="line">prob = cp.Problem(cp.Minimize(c.T@x),</span><br><span class="line">                 [A @ x &lt;= b])</span><br><span class="line">prob.solve()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Print result.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nThe optimal value is&quot;</span>, prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A solution x is&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A dual solution is&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(prob.constraints[<span class="number">0</span>].dual_value)</span><br></pre></td></tr></table></figure></li></ul><h2 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h2><ul><li>多目标规划（Multi-Objective Optimization, MOO） 是一种优化方法，旨在同时优化多个目标函数。与单目标优化不同，多目标规划通常没有唯一的最优解，而是存在一组帕累托最优解（Pareto Optimal Solutions），这些解在多个目标之间实现了最佳权衡。</li></ul><h3 id="线性加权和法"><a href="#线性加权和法" class="headerlink" title="线性加权和法"></a>线性加权和法</h3><ul><li><p>线性加权和法对每个目标函数赋予一个权重, 从而把多目标规划转化为单目标规划。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标函数（加权求和）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">x</span>):</span><br><span class="line">    f1 = x[<span class="number">0</span>]**<span class="number">2</span> + x[<span class="number">1</span>]**<span class="number">2</span>  <span class="comment"># 目标1: 最小化 x[0]^2 + x[1]^2</span></span><br><span class="line">    f2 = (x[<span class="number">0</span>] - <span class="number">1</span>)**<span class="number">2</span> + (x[<span class="number">1</span>] - <span class="number">1</span>)**<span class="number">2</span>  <span class="comment"># 目标2: 最小化 (x[0]-1)^2 + (x[1]-1)^2</span></span><br><span class="line">    w1, w2 = <span class="number">0.5</span>, <span class="number">0.5</span>  <span class="comment"># 权重</span></span><br><span class="line">    <span class="keyword">return</span> w1 * f1 + w2 * f2  <span class="comment"># 加权求和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义约束条件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constraint</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] + x[<span class="number">1</span>] - <span class="number">1</span>  <span class="comment"># 约束: x[0] + x[1] = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始值</span></span><br><span class="line">x0 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">solution = minimize(objective, x0, constraints=&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;eq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: constraint&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解:&quot;</span>, solution.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;目标函数值:&quot;</span>, solution.fun)</span><br></pre></td></tr></table></figure></li></ul><h3 id="主要目标法-epsilon-约束方法"><a href="#主要目标法-epsilon-约束方法" class="headerlink" title="主要目标法($\epsilon$ -约束方法)"></a>主要目标法($\epsilon$ -约束方法)</h3><ul><li><p>选择一个目标作为主目标，其他目标转化为约束条件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义主要目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primary_objective</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]**<span class="number">2</span> + x[<span class="number">1</span>]**<span class="number">2</span>  <span class="comment"># 主要目标: 最小化 x[0]^2 + x[1]^2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义次要目标函数的约束条件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secondary_constraint</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - ((x[<span class="number">0</span>] - <span class="number">1</span>)**<span class="number">2</span> + (x[<span class="number">1</span>] - <span class="number">1</span>)**<span class="number">2</span>)  <span class="comment"># 约束: (x[0]-1)^2 + (x[1]-1)^2 &lt;= 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始值</span></span><br><span class="line">x0 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义约束条件</span></span><br><span class="line">constraints = [&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: secondary_constraint&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">solution = minimize(</span><br><span class="line">    primary_objective,  <span class="comment"># 主要目标函数</span></span><br><span class="line">    x0,  <span class="comment"># 初始值</span></span><br><span class="line">    constraints=constraints  <span class="comment"># 约束条件</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解:&quot;</span>, solution.x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主要目标函数值:&quot;</span>, solution.fun)</span><br></pre></td></tr></table></figure></li></ul><h2 id="最大最小化规划"><a href="#最大最小化规划" class="headerlink" title="最大最小化规划"></a>最大最小化规划</h2><ul><li><p>最大最小化规划（Maximin Optimization）是一种特殊的优化问题，其核心目标是最大化最小值。在这种规划中，我们寻找一个解决方案，使得所有可能结果中的最小值尽可能大。这种方法特别适用于那些需要确保最坏情况下的最佳性能的场景，例如资源分配、公平性问题等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">x</span>):</span><br><span class="line">    t = x[<span class="number">2</span>]  <span class="comment"># 辅助变量 t</span></span><br><span class="line">    <span class="keyword">return</span> -t  <span class="comment"># 最大化 t，等价于最小化 -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义约束条件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constraint1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] + <span class="number">2</span> * x[<span class="number">1</span>] - x[<span class="number">2</span>]  <span class="comment"># f1(x) &gt;= t</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constraint2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x[<span class="number">0</span>] + x[<span class="number">1</span>] - x[<span class="number">2</span>]  <span class="comment"># f2(x) &gt;= t</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constraint3</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> - (x[<span class="number">0</span>] + x[<span class="number">1</span>])  <span class="comment"># x1 + x2 &lt;= 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始值</span></span><br><span class="line">x0 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]  <span class="comment"># [x1, x2, t]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义约束条件</span></span><br><span class="line">constraints = [</span><br><span class="line">    &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: constraint1&#125;,  <span class="comment"># f1(x) &gt;= t</span></span><br><span class="line">    &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: constraint2&#125;,  <span class="comment"># f2(x) &gt;= t</span></span><br><span class="line">    &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>: constraint3&#125;   <span class="comment"># x1 + x2 &lt;= 10</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量的边界</span></span><br><span class="line">bounds = [</span><br><span class="line">    (<span class="number">0</span>, <span class="literal">None</span>),  <span class="comment"># x1 &gt;= 0</span></span><br><span class="line">    (<span class="number">0</span>, <span class="literal">None</span>),  <span class="comment"># x2 &gt;= 0</span></span><br><span class="line">    (<span class="literal">None</span>, <span class="literal">None</span>)  <span class="comment"># t 无边界</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">solution = minimize(</span><br><span class="line">    objective,  <span class="comment"># 目标函数</span></span><br><span class="line">    x0,  <span class="comment"># 初始值</span></span><br><span class="line">    method=<span class="string">&#x27;SLSQP&#x27;</span>,  <span class="comment"># 使用 SLSQP 算法</span></span><br><span class="line">    constraints=constraints,  <span class="comment"># 约束条件</span></span><br><span class="line">    bounds=bounds  <span class="comment"># 变量边界</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x1 =&quot;</span>, solution.x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x2 =&quot;</span>, solution.x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t =&quot;</span>, solution.x[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;目标函数值:&quot;</span>, -solution.fun)  <span class="comment"># 最大化 t，所以取负值</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
